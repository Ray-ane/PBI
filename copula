/**
 * Power BI Custom Visual for Copula Modeling
 * This visual analyzes the joint distribution of two bond error series
 * using t-copula modeling to capture their dependence structure.
 */

"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

// Constants
const CHART_MARGINS = { top: 40, right: 30, bottom: 60, left: 60 };

/**
 * Interface representing a single row of input data
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
}

/**
 * Interface for bond error data points
 */
interface BondErrorPoint {
    date: Date;
    bond1Error: number;
    bond2Error: number;
}

/**
 * Interface for copula parameters
 */
interface CopulaParams {
    rho: number;        // Correlation parameter
    df: number;         // Degrees of freedom for t-copula
    u1: number[];       // Marginal probabilities for Bond1
    u2: number[];       // Marginal probabilities for Bond2
}

/**
 * Power BI Custom Visual for Copula Modeling
 */
export class Visual implements IVisual {
    // DOM Elements
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    private dropdownPairs: HTMLSelectElement;
    private dfSlider: HTMLInputElement;

    // Data Storage
    private allData: DataRow[] = [];
    private copulaModel: CopulaModel;

    // Viewport Configuration
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };

    constructor(options: VisualConstructorOptions) {
        this.initializeVisual(options);
        this.copulaModel = new CopulaModel();
    }

    /**
     * Initializes the visual with controls and event listeners
     */
    private initializeVisual(options: VisualConstructorOptions): void {
        this.target = options.element;
        this.target.innerHTML = "";

        this.createControlContainer();
        this.createTooltip();
        this.initializeControls();
        this.createSVGContainer();
    }

    /**
     * Creates the tooltip element
     */
    private createTooltip(): void {
        const tooltip = document.createElement("div");
        tooltip.id = "tooltip";
        tooltip.style.position = "absolute";
        tooltip.style.padding = "8px";
        tooltip.style.background = "rgba(255, 255, 255, 0.9)";
        tooltip.style.border = "1px solid #ddd";
        tooltip.style.borderRadius = "4px";
        tooltip.style.pointerEvents = "none";
        tooltip.style.fontSize = "12px";
        tooltip.style.zIndex = "1000";
        this.target.appendChild(tooltip);
    }

    /**
     * Creates the control container with dropdown and slider
     */
    private createControlContainer(): void {
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        controlContainer.innerHTML = `
            <div id="dropdown-container">
                <label for="pairDropdown">Select Pair (Bond1 vs Bond2):</label>
                <select id="pairDropdown" style="font-size: 10px;"></select>
            </div>
            <div id="slider-container">
                <div>
                    <label for="dfSlider">Degrees of Freedom:</label>
                    <input id="dfSlider" type="range" min="1" max="20" step="0.1" value="5">
                    <span id="dfValue">5.0</span>
                </div>
            </div>
        `;
        this.target.appendChild(controlContainer);
    }

    /**
     * Initializes control elements and event listeners
     */
    private initializeControls(): void {
        this.dropdownPairs = document.getElementById("pairDropdown") as HTMLSelectElement;
        this.dfSlider = document.getElementById("dfSlider") as HTMLInputElement;

        this.dropdownPairs.addEventListener("change", () => this.updateChartsInner());
        this.dfSlider.addEventListener("input", () => {
            (document.getElementById("dfValue") as HTMLElement).innerText = this.dfSlider.value;
            this.updateChartsInner();
        });
    }

    /**
     * Creates the SVG container for the chart
     */
    private createSVGContainer(): void {
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("copula-visual", true);
    }

    /**
     * Parses a single row of data with validation
     */
    private parseDataRow(row: any[]): DataRow | null {
        let dateVal: Date;
        if (row[0] instanceof Date) {
            dateVal = row[0];
        } else if (typeof row[0] === 'string') {
            dateVal = new Date(row[0]);
            if (isNaN(dateVal.getTime())) return null;
        } else if (typeof row[0] === 'number') {
            dateVal = new Date(row[0]);
        } else {
            return null;
        }

        return {
            inputdate: dateVal,
            context1: row[1]?.toString() || "",
            isin1: row[2]?.toString() || "",
            isin2: row[3]?.toString() || "",
            bond1: row[4]?.toString() || "",
            bond2: row[5]?.toString() || "",
            error: +row[6]
        };
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews?.[0];
        if (!dataView?.table) return;
        
        this.currentViewport = options.viewport || { width: 600, height: 300 };

        const rows = dataView.table.rows;
        if (!rows?.length) return;

        // Parse and sort data
        this.allData = rows
            .map(row => this.parseDataRow(row))
            .filter((row): row is DataRow => row !== null)
            .sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());

        // Update dropdown with latest P_VALUE rows
        this.updateDropdown();
        
        // Update chart if data is available
        if (this.allData.length > 0) {
            this.updateChartsInner();
        }
    }

    /**
     * Updates the dropdown with the latest P_VALUE rows
     */
    private updateDropdown(): void {
        const pValueRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "P_VALUE"
        );

        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        const maxDate = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const latestRows = pValueRows.filter(d => 
            d.inputdate.toDateString() === new Date(maxDate).toDateString()
        );

        const uniquePairs = Array.from(new Set(
            latestRows.map(row => `${row.bond1} vs ${row.bond2}`)
        ));

        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pair => {
            const opt = document.createElement("option");
            opt.value = pair;
            opt.text = pair;
            opt.style.fontSize = "10px";
            this.dropdownPairs.appendChild(opt);
        });

        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }
    }

    private updateChartsInner() {
        if (this.dropdownPairs.options.length === 0) return;
        
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        
        const [selectedBond1, selectedBond2] = selectedPair.split(" vs ");

        // Filter and compute error series
        const errorRows = this.allData.filter(d => 
            d.context1.trim().toUpperCase() === "ERROR"
        );

        const mapBond1 = new Map<string, number>();
        const mapBond2 = new Map<string, number>();
        
        errorRows.forEach(d => {
            const key = d.inputdate.toDateString();
            if (d.bond1.trim() === selectedBond1.trim()) {
                mapBond1.set(key, d.error);
            } else if (d.bond1.trim() === selectedBond2.trim()) {
                mapBond2.set(key, d.error);
            }
        });

        // Create bond error points
        const bondErrorPoints = Array.from(mapBond1.entries())
            .filter(([key]) => mapBond2.has(key))
            .map(([key, val1]) => ({
                date: new Date(key),
                bond1Error: val1,
                bond2Error: mapBond2.get(key)!
            }))
            .sort((a, b) => a.date.getTime() - b.date.getTime());

        if (bondErrorPoints.length < 2) {
            this.renderChart(false);
            return;
        }

        // Update copula model with new data and degrees of freedom
        this.copulaModel.setData(
            bondErrorPoints.map(d => d.bond1Error),
            bondErrorPoints.map(d => d.bond2Error),
            bondErrorPoints.map(d => d.date)
        );
        this.copulaModel.setDegreesOfFreedom(parseFloat(this.dfSlider.value));

        // Render chart
        this.renderChart(true);
    }

    private renderChart(hasData: boolean) {
        // Clear previous chart
        this.svg.selectAll("*").remove();

        // Set up dimensions
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        this.svg.attr("width", width).attr("height", height);

        // Calculate inner dimensions
        const innerWidth = width - CHART_MARGINS.left - CHART_MARGINS.right;
        const innerHeight = height - CHART_MARGINS.top - CHART_MARGINS.bottom;

        // Create main chart group
        const g = this.svg.append("g")
            .attr("transform", `translate(${CHART_MARGINS.left}, ${CHART_MARGINS.top})`);

        // Check for data
        if (!hasData) {
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "red")
                .style("font-size", "14px")
                .text("No data to display.");
            return;
        }

        // Create scales
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);

        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);

        // Create color scale
        const colorScale = d3.scaleSequential()
            .domain([0, 2])
            .interpolator(d3.interpolateViridis);

        // Create grid points
        const gridSize = 50;
        const xPoints = d3.range(gridSize).map(i => i / (gridSize - 1));
        const yPoints = d3.range(gridSize).map(i => i / (gridSize - 1));

        // Compute copula density for each grid point
        const densityData = xPoints.map(x => 
            yPoints.map(y => ({
                x,
                y,
                density: this.copulaModel.computeCopulaDensity(x, y)
            }))
        ).flat();

        // Create heatmap
        g.selectAll("rect")
            .data(densityData)
            .enter()
            .append("rect")
            .attr("x", d => xScale(d.x))
            .attr("y", d => yScale(d.y))
            .attr("width", xScale(1 / (gridSize - 1)))
            .attr("height", yScale(1 / (gridSize - 1)))
            .attr("fill", d => colorScale(d.density))
            .attr("opacity", 0.8);

        // Add axes
        const xAxis = d3.axisBottom(xScale)
            .ticks(5)
            .tickFormat(d3.format(".2f"));

        const yAxis = d3.axisLeft(yScale)
            .ticks(5)
            .tickFormat(d3.format(".2f"));

        // Add x-axis
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(xAxis);

        // Style x-axis
        xAxisGroup.selectAll("text")
            .attr("transform", "rotate(-20)")
            .style("text-anchor", "end")
            .style("font-size", "10px")
            .style("fill", "#000")
            .attr("dy", "1em")
            .attr("dx", "-0.5em");

        xAxisGroup.selectAll("line")
            .style("stroke", "#000")
            .style("stroke-width", "1px");

        xAxisGroup.selectAll("path")
            .style("stroke", "#000")
            .style("stroke-width", "1px");

        // Add y-axis
        const yAxisGroup = g.append("g")
            .call(yAxis);

        yAxisGroup.selectAll("text")
            .style("font-size", "12px")
            .style("fill", "#000");

        yAxisGroup.selectAll("line")
            .style("stroke", "#000")
            .style("stroke-width", "1px");

        yAxisGroup.selectAll("path")
            .style("stroke", "#000")
            .style("stroke-width", "1px");

        // Add axis labels
        g.append("text")
            .attr("x", innerWidth / 2)
            .attr("y", innerHeight + 40)
            .attr("text-anchor", "middle")
            .style("font-size", "12px")
            .style("fill", "#000")
            .text("Bond1 Error (U1)");

        g.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", -innerHeight / 2)
            .attr("y", -40)
            .attr("text-anchor", "middle")
            .style("font-size", "12px")
            .style("fill", "#000")
            .text("Bond2 Error (U2)");

        // Add title
        g.append("text")
            .attr("x", innerWidth / 2)
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .style("font-weight", "bold")
            .text("Copula Density Plot");

        // Add correlation info
        g.append("text")
            .attr("x", innerWidth - 10)
            .attr("y", -10)
            .attr("text-anchor", "end")
            .style("font-size", "12px")
            .style("fill", "#333")
            .text(`Correlation (ρ) = ${this.copulaModel.getCorrelation().toFixed(3)}`);

        // Add tooltip
        const tooltip = d3.select("#tooltip");
        const bisectX = d3.bisector<{x: number, y: number, density: number}, number>(d => d.x).left;

        // Add tooltip interaction overlay
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .style("fill", "none")
            .style("pointer-events", "all")
            .on("mousemove", (event) => {
                const mouseX = xScale.invert(d3.pointer(event)[0]);
                const mouseY = yScale.invert(d3.pointer(event)[1]);
                const index = bisectX(densityData, mouseX);
                const d = densityData[index];
                if (d) {
                    tooltip
                        .style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(`U1: ${d.x.toFixed(3)}<br/>U2: ${d.y.toFixed(3)}<br/>Density: ${d.density.toFixed(3)}`);
                }
            })
            .on("mouseout", () => {
                tooltip.style("opacity", 0);
            });
    }
}

/**
 * Class for copula modeling and visualization
 */
class CopulaModel {
    private data: BondErrorPoint[] = [];
    private params: CopulaParams;
    private margin: { top: number; right: number; bottom: number; left: number } = CHART_MARGINS;

    constructor() {
        this.params = {
            rho: 0,
            df: 5,
            u1: [],
            u2: []
        };
    }

    /**
     * Gets the current correlation parameter
     */
    public getCorrelation(): number {
        return this.params.rho;
    }

    /**
     * Sets the degrees of freedom parameter
     */
    public setDegreesOfFreedom(df: number): void {
        this.params.df = df;
    }

    /**
     * Sets the bond error data and computes marginal probabilities
     */
    public setData(bond1Errors: number[], bond2Errors: number[], dates: Date[]): void {
        if (bond1Errors.length !== bond2Errors.length) {
            throw new Error("Bond error arrays must have the same length");
        }

        // Create data points
        this.data = dates.map((date, i) => ({
            date,
            bond1Error: bond1Errors[i],
            bond2Error: bond2Errors[i]
        }));

        // Compute empirical marginal distributions
        this.computeMarginals();
    }

    /**
     * Computes empirical marginal distributions using rank transformation
     */
    private computeMarginals(): void {
        const n = this.data.length;
        
        // Sort errors for rank computation
        const sortedBond1 = [...this.data].sort((a, b) => a.bond1Error - b.bond1Error);
        const sortedBond2 = [...this.data].sort((a, b) => a.bond2Error - b.bond2Error);

        // Compute ranks and convert to probabilities
        this.params.u1 = this.data.map(point => {
            const rank = sortedBond1.findIndex(d => d.bond1Error === point.bond1Error);
            return (rank + 1) / (n + 1);
        });

        this.params.u2 = this.data.map(point => {
            const rank = sortedBond2.findIndex(d => d.bond2Error === point.bond2Error);
            return (rank + 1) / (n + 1);
        });

        // Compute correlation parameter
        this.computeCorrelation();
    }

    /**
     * Computes the correlation parameter using Kendall's tau
     */
    private computeCorrelation(): void {
        const n = this.data.length;
        let concordant = 0;
        let discordant = 0;

        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const x1 = this.data[i].bond1Error;
                const x2 = this.data[i].bond2Error;
                const y1 = this.data[j].bond1Error;
                const y2 = this.data[j].bond2Error;

                if ((x1 - y1) * (x2 - y2) > 0) {
                    concordant++;
                } else if ((x1 - y1) * (x2 - y2) < 0) {
                    discordant++;
                }
            }
        }

        const tau = (concordant - discordant) / (n * (n - 1) / 2);
        this.params.rho = Math.sin(tau * Math.PI / 2);
    }

    /**
     * Computes the t-copula density at given points
     */
    public computeCopulaDensity(u1: number, u2: number): number {
        const { rho, df } = this.params;
        
        try {
            // Convert to standard normal quantiles
            const x1 = this.quantileNormal(u1);
            const x2 = this.quantileNormal(u2);

            // Compute t-copula density
            const rho2 = rho * rho;
            const t1 = this.quantileT(u1, df);
            const t2 = this.quantileT(u2, df);
            
            const num = (1 + (t1 * t1 + t2 * t2 - 2 * rho * t1 * t2) / (df * (1 - rho2)));
            const den = Math.sqrt(1 - rho2) * 
                       this.tDensity(t1, df) * 
                       this.tDensity(t2, df);

            return num / den;
        } catch (error) {
            console.error(`Error in computeCopulaDensity: u1=${u1}, u2=${u2}, df=${df}`);
            console.error(error);
            throw error;
        }
    }

    /**
     * Computes the standard normal quantile (inverse CDF)
     * Using the approximation method by Peter J. Acklam
     */
    private quantileNormal(p: number): number {
        // Input validation
        if (p <= 0 || p >= 1) {
            console.error(`Invalid probability in quantileNormal: ${p}`);
            throw new Error(`Probability must be between 0 and 1, got ${p}`);
        }

        // Coefficients for the approximation
        const a1 = -3.969683028665376e+01;
        const a2 = 2.209460984245205e+02;
        const a3 = -2.759285104469687e+02;
        const a4 = 1.383577518672690e+02;
        const a5 = -3.066479806614716e+01;
        const a6 = 2.506628277459239e+00;

        const b1 = -5.447609879822406e+01;
        const b2 = 1.615858368580409e+02;
        const b3 = -1.556989798598866e+02;
        const b4 = 6.680131188771972e+01;
        const b5 = -1.328068155288572e+01;

        const c1 = -7.784894002430293e-03;
        const c2 = -3.223964580411365e-01;
        const c3 = -2.400758277161838e+00;
        const c4 = -2.549732539343734e+00;
        const c5 = 4.374664141464968e+00;
        const c6 = 2.938163982698783e+00;

        const d1 = 7.784695709041462e-03;
        const d2 = 3.224671290700398e-01;
        const d3 = 2.445134137142996e+00;
        const d4 = 3.754408661907416e+00;

        // Define break points
        const p_low = 0.02425;
        const p_high = 1 - p_low;

        let q, r;

        // Rational approximation for lower region
        if (p < p_low) {
            q = Math.sqrt(-2 * Math.log(p));
            return (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                   ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
        }
        // Rational approximation for upper region
        else if (p > p_high) {
            q = Math.sqrt(-2 * Math.log(1 - p));
            return -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
                    ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
        }
        // Rational approximation for central region
        else {
            q = p - 0.5;
            r = q * q;
            return (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q /
                   (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
        }
    }

    /**
     * Computes the t-distribution quantile (inverse CDF)
     * Using the approximation method by Hill (1970)
     */
    private quantileT(p: number, df: number): number {
        // Input validation
        if (p <= 0 || p >= 1) {
            console.error(`Invalid probability in quantileT: ${p}, df: ${df}`);
            throw new Error(`Probability must be between 0 and 1, got ${p}`);
        }

        // For large degrees of freedom, use normal approximation
        if (df > 100) {
            return this.quantileNormal(p);
        }

        // For small degrees of freedom, use Hill's approximation
        const a = df - 0.5;
        const b = 48 * a * a;
        let z = this.quantileNormal(p);
        let z2 = z * z;
        let z3 = z2 * z;
        let z4 = z3 * z;
        let z5 = z4 * z;
        let z6 = z5 * z;
        let z7 = z6 * z;
        let z8 = z7 * z;

        let g = z + (z3 + z) / (4 * a) +
            (5 * z5 + 16 * z3 + 3 * z) / (96 * a * a) +
            (3 * z7 + 19 * z5 + 17 * z3 - 15 * z) / (384 * a * a * a) +
            (79 * z8 + 776 * z6 + 1482 * z4 - 1920 * z2 - 945) / (92160 * a * a * a * a);

        return g;
    }

    /**
     * Computes the t-distribution density
     */
    private tDensity(x: number, df: number): number {
        return Math.pow(1 + x * x / df, -(df + 1) / 2) / 
               (Math.sqrt(df * Math.PI) * this.gamma(df / 2) / this.gamma((df + 1) / 2));
    }

    /**
     * Computes the gamma function
     */
    private gamma(x: number): number {
        if (x < 0.5) {
            return Math.PI / (Math.sin(Math.PI * x) * this.gamma(1 - x));
        }
        x -= 1;
        let a = 0.99999999999980993;
        const p = [
            676.5203681218851, -1259.1392167224028, 771.32342877765313,
            -176.61502916214059, 12.507343278686905, -0.13857109526572012,
            9.9843695780195716e-6, 1.5056327351493116e-7
        ];
        for (let i = 0; i < p.length; i++) {
            a += p[i] / (x + i + 1);
        }
        return Math.sqrt(2 * Math.PI) * Math.pow(x + p.length - 0.5, x + 0.5) * Math.exp(-x - p.length + 0.5) * a;
    }
} 
