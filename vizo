"use strict";

import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

export class Visual implements IVisual {
    private target: HTMLElement;
    private dataView: DataView | undefined;

    // Store all historical data by Geo:
    private allData: { [geo: string]: { year: number; ratio: number }[] } = {};
    private geos: string[] = [];
    private selectedGeo: string | undefined;

    // Slider values (user enters % and bp; converted later)
    private sliderValues = {
        bondYield: 2,       // 10-year Bond Yield (%)
        spread: 50,         // Spread vs Bund (bp)
        inflation: 2,       // Inflation (YoY %)
        realGrowth: 2,      // Real GDP Growth (YoY %)
        primarySurplus: 0   // Primary Surplus (% of GDP)
    };

    constructor(options: VisualConstructorOptions) {
        this.target = options.element;

        // Build HTML structure:
        // 1. Dropdown for Geo selection
        // 2. Sliders for parameters
        // 3. Chart area for D3
        this.target.innerHTML = `
            <div style="display: flex; flex-direction: column; height: 100%;">
                <div style="padding: 5px;">
                    <label>Geo</label><br>
                    <select id="geoDropdown"></select>
                </div>
                <div style="display: flex; flex: 1 1 auto; border-top: 1px solid #ccc; padding: 10px;">
                    <div style="width: 200px; padding-right: 10px; border-right: 1px solid #ccc;">
                        <div style="margin-bottom: 10px;">
                            <label>10-Year Bond Yield (%)</label><br>
                            <input type="range" id="bondYield" min="-0.1" max="5" step="0.1" value="2">
                            <span id="bondYieldVal">2</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>Spread vs Bund (bp)</label><br>
                            <input type="range" id="spread" min="0" max="300" step="10" value="50">
                            <span id="spreadVal">50</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>Inflation (YoY %)</label><br>
                            <input type="range" id="inflation" min="0" max="10" step="0.1" value="2">
                            <span id="inflationVal">2</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>Real GDP Growth (YoY %)</label><br>
                            <input type="range" id="realGrowth" min="-5" max="10" step="0.1" value="2">
                            <span id="realGrowthVal">2</span>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label>Primary Surplus (% of GDP)</label><br>
                            <input type="range" id="primarySurplus" min="-5" max="5" step="0.1" value="0">
                            <span id="primarySurplusVal">0</span>
                        </div>
                    </div>
                    <div style="flex-grow: 1; padding: 10px;">
                        <div id="d3Chart" style="width: 100%; height: 100%; position: relative;"></div>
                    </div>
                </div>
            </div>
        `;

        // Attach slider listeners
        const self = this;
        (document.getElementById("bondYield") as HTMLInputElement).addEventListener("input", function () {
            self.sliderValues.bondYield = parseFloat(this.value);
            document.getElementById("bondYieldVal")!.textContent = this.value;
            self.updateChart();
        });
        (document.getElementById("spread") as HTMLInputElement).addEventListener("input", function () {
            self.sliderValues.spread = parseFloat(this.value);
            document.getElementById("spreadVal")!.textContent = this.value;
            self.updateChart();
        });
        (document.getElementById("inflation") as HTMLInputElement).addEventListener("input", function () {
            self.sliderValues.inflation = parseFloat(this.value);
            document.getElementById("inflationVal")!.textContent = this.value;
            self.updateChart();
        });
        (document.getElementById("realGrowth") as HTMLInputElement).addEventListener("input", function () {
            self.sliderValues.realGrowth = parseFloat(this.value);
            document.getElementById("realGrowthVal")!.textContent = this.value;
            self.updateChart();
        });
        (document.getElementById("primarySurplus") as HTMLInputElement).addEventListener("input", function () {
            self.sliderValues.primarySurplus = parseFloat(this.value);
            document.getElementById("primarySurplusVal")!.textContent = this.value;
            self.updateChart();
        });

        // Attach Geo dropdown listener
        (document.getElementById("geoDropdown") as HTMLSelectElement).addEventListener("change", function () {
            self.selectedGeo = this.value;
            self.updateChart();
        });
    }

    public update(options: VisualUpdateOptions): void {
        if (options.dataViews && options.dataViews[0]) {
            this.dataView = options.dataViews[0];
        }
        // Parse data from DataView, populate dropdown, and update chart
        this.parseData();
        this.populateDropdown();
        this.updateChart();
    }

    // Parse table rows: [Geo, Year, GrossDebt, NominalGDP]
    private parseData(): void {
        this.allData = {};
        this.geos = [];
        if (!this.dataView || !this.dataView.table) {
            return;
        }
        const table = this.dataView.table;
        for (let i = 0; i < table.rows.length; i++) {
            const row = table.rows[i];
            const geo = String(row[0]);
            const year = +row[1];
            const grossDebt = +row[2];
            const nominalGDP = +row[3];
            if (nominalGDP > 0) {
                const ratio = (grossDebt / nominalGDP) * 100;
                if (!this.allData[geo]) {
                    this.allData[geo] = [];
                }
                this.allData[geo].push({ year: year, ratio: ratio });
            }
        }
        // Sort each geo's data by year
        for (const g in this.allData) {
            this.allData[g].sort((a, b) => a.year - b.year);
        }
        this.geos = Object.keys(this.allData);
    }

    // Populate the Geo dropdown
    private populateDropdown(): void {
        const dropdown = document.getElementById("geoDropdown") as HTMLSelectElement;
        dropdown.innerHTML = "";
        this.geos.forEach((geo) => {
            const option = document.createElement("option");
            option.value = geo;
            option.text = geo;
            dropdown.appendChild(option);
        });
        // Default selection if none set or if current selection is missing
        if (!this.selectedGeo || this.geos.indexOf(this.selectedGeo) === -1) {
            this.selectedGeo = this.geos.length > 0 ? this.geos[0] : undefined;
        }
        if (this.selectedGeo) {
            dropdown.value = this.selectedGeo;
        }
    }

    // Update the chart: filter historical data, simulate, and render
    private updateChart(): void {
        if (!this.selectedGeo || !this.allData[this.selectedGeo]) {
            return;
        }
        // Historical data: years <= 2023
        const historical = this.allData[this.selectedGeo].filter(d => d.year <= 2023);
        if (historical.length === 0) {
            return;
        }
        const lastHistRatio = historical[historical.length - 1].ratio;
        const simulated = this.simulateDebtGDP(lastHistRatio);
        const combined = historical.concat(simulated);
        this.renderLineChart(combined);
    }

    // Simulation using the structural equation:
    // D_{t+1}/Y_{t+1} = ( [1 + (Y_{10,t} + Spread/10000)] / [(1 + π_t) (1 + g_real,t)] ) * (D_t/Y_t) - PS_t
    private simulateDebtGDP(lastHistRatio: number): { year: number, ratio: number }[] {
        const result: { year: number, ratio: number }[] = [];
        let currentRatio = lastHistRatio;

        // Convert slider values: user "2" → 0.02, "50" bp → 0.005, etc.
        const i_bond = this.sliderValues.bondYield / 100;
        const i_spread = this.sliderValues.spread / 10000;
        const i_inflation = this.sliderValues.inflation / 100;
        const i_real = this.sliderValues.realGrowth / 100;
        const i_PS = this.sliderValues.primarySurplus / 100;

        for (let year = 2024; year <= 2050; year++) {
            const numerator = 1 + (i_bond + i_spread);
            const denominator = (1 + i_inflation) * (1 + i_real);
            currentRatio = (numerator / denominator) * currentRatio - i_PS;
            result.push({ year: year, ratio: currentRatio });
        }
        return result;
    }

    // Render a line chart using D3.js with a simple line and a tooltip.
    private renderLineChart(data: { year: number, ratio: number }[]): void {
        const chartDiv = d3.select("#d3Chart");
        chartDiv.selectAll("*").remove();

        const margin = { top: 20, right: 20, bottom: 30, left: 50 };
        const width = (chartDiv.node() as HTMLElement).clientWidth || 400;
        const height = (chartDiv.node() as HTMLElement).clientHeight || 300;
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        const svg = chartDiv.append("svg")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Define scales
        const x = d3.scaleLinear()
            .domain(d3.extent(data, d => d.year) as [number, number])
            .range([0, innerWidth]);

        const y = d3.scaleLinear()
            .domain([d3.min(data, d => d.ratio) ?? 0, d3.max(data, d => d.ratio) ?? 100])
            .nice()
            .range([innerHeight, 0]);

        // Draw axes
        const xAxis = d3.axisBottom(x).tickFormat(d3.format("d"));
        const yAxis = d3.axisLeft(y);
        g.append("g")
            .attr("transform", `translate(0,${innerHeight})`)
            .call(xAxis);
        g.append("g")
            .call(yAxis);

        // Draw the line path (simple line, no dots)
        const line = d3.line<{ year: number, ratio: number }>()
            .x(d => x(d.year))
            .y(d => y(d.ratio));
        g.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
            .attr("d", line);

        // Create a tooltip div appended to the chart container
        const tooltip = chartDiv.append("div")
            .attr("class", "tooltip")
            .style("position", "absolute")
            .style("background", "#fff")
            .style("border", "1px solid #ccc")
            .style("padding", "5px")
            .style("pointer-events", "none")
            .style("display", "none");

        // Append an overlay rectangle to capture mouse events for tooltip display
        g.append("rect")
            .attr("width", innerWidth)
            .attr("height", innerHeight)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousemove", function(event) {
                // Get mouse position relative to the chart group
                const [mx, my] = d3.pointer(event);
                const x0 = x.invert(mx);
                // Use a bisector to find the nearest data point by year
                const bisect = d3.bisector((d: {year: number, ratio: number}) => d.year).left;
                const idx = bisect(data, x0);
                const d0 = data[idx - 1];
                const d1 = data[idx];
                let dNearest = d0;
                if (d1 && (x0 - d0.year > d1.year - x0)) {
                    dNearest = d1;
                }
                tooltip.style("display", "block")
                    .html(`Year: ${dNearest.year}<br>Ratio: ${dNearest.ratio.toFixed(2)}%`)
                    .style("left", (mx + margin.left + 10) + "px")
                    .style("top", (my + margin.top - 20) + "px");
            })
            .on("mouseout", function() {
                tooltip.style("display", "none");
            });
    }
}
