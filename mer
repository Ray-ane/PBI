"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

/**
 * Data schema:
 *  inputdate, context1, isin1, isin2, Bond1, Bond2, Error
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
}

/** For the difference series (Error for Bond1 minus Error for Bond2) */
interface DiffPoint {
    inputdate: Date;
    diff: number;
}

export class Visual implements IVisual {
    private target: HTMLElement;
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;

    // Dropdown for pair selection (formatted as "isin1||isin2")
    private dropdownPairs: HTMLSelectElement;

    // All parsed data.
    private allData: DataRow[] = [];

    // Computed difference series.
    private diffSeries: DiffPoint[] = [];

    // OU parameters computed from the diff series.
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    private delta: number = 1; // time step in ms computed from dates

    // OU scaling sliders.
    private lambdaSlider: HTMLInputElement;
    private sigmaSlider: HTMLInputElement;

    // Current viewport dimensions.
    private currentViewport: { width: number; height: number } = { width: 600, height: 300 };

    // Flag indicating if the diff series passed the ADF test.
    private diffSeriesStationary: boolean = false;

    // Chart margins.
    private margin: { top: number; right: number; bottom: number; left: number } =
        { top: 20, right: 30, bottom: 50, left: 50 };

    constructor(options: VisualConstructorOptions) {
        this.target = options.element;
        this.target.innerHTML = "";

        // Create a container for controls (dropdown and sliders).
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        controlContainer.style.marginBottom = "20px";
        controlContainer.innerHTML = `
            <div id="dropdown-container">
                <label for="pairDropdown">Select Pair (isin1||isin2):</label>
                <select id="pairDropdown"></select>
            </div>
            <div id="slider-container">
            <div>
                <label for="lambdaSlider">Lambda Factor:</label>
                <input id="lambdaSlider" type="range" min="0.5" max="2.0" step="0.01" value="1.0">
                <span id="lambdaValue">1.0</span>
            </div>
            <div>
                <label for="sigmaSlider">Sigma Factor:</label>
                <input id="sigmaSlider" type="range" min="0.5" max="2.0" step="0.01" value="1.0">
                <span id="sigmaValue">1.0</span>
                </div>
            </div>
        `;
        this.target.appendChild(controlContainer);

        // Get references for controls.
        this.dropdownPairs = document.getElementById("pairDropdown") as HTMLSelectElement;
        this.lambdaSlider = document.getElementById("lambdaSlider") as HTMLInputElement;
        this.sigmaSlider = document.getElementById("sigmaSlider") as HTMLInputElement;

        // Attach event listeners.
        this.dropdownPairs.addEventListener("change", () => {
            console.log("Dropdown changed. Selected pair:", this.dropdownPairs.value);
            this.updateChartsInner();
        });
        this.lambdaSlider.addEventListener("input", () => {
            (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
            this.updateChartsInner();
        });
        this.sigmaSlider.addEventListener("input", () => {
            (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
            this.updateChartsInner();
        });

        // Create the SVG container for the chart
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("ou-estimation-visual", true);
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews && options.dataViews[0];
        if (!dataView || !dataView.table) return;
        this.currentViewport = options.viewport || { width: 600, height: 300 };

        // Reset sliders to default.
        this.lambdaSlider.value = "1.0";
        this.sigmaSlider.value = "1.0";
        (document.getElementById("lambdaValue") as HTMLElement).innerText = "1.0";
        (document.getElementById("sigmaValue") as HTMLElement).innerText = "1.0";

        const rows = dataView.table.rows;
        if (!rows || rows.length === 0) return;

        // Parse all rows with date validation
        let parsed: DataRow[] = [];
        rows.forEach((row: any[]) => {
            // Ensure date is properly parsed
            let dateVal: Date;
            if (row[0] instanceof Date) {
                dateVal = row[0];
            } else if (typeof row[0] === 'string') {
                // Try parsing string date
                dateVal = new Date(row[0]);
                if (isNaN(dateVal.getTime())) {
                    console.error("Invalid date format:", row[0]);
                    return;
                }
            } else if (typeof row[0] === 'number') {
                // Handle timestamp
                dateVal = new Date(row[0]);
            } else {
                console.error("Unsupported date format:", row[0]);
                return;
            }

            const context1 = row[1] ? row[1].toString() : "";
            const isin1 = row[2] ? row[2].toString() : "";
            const isin2 = row[3] ? row[3].toString() : "";
            const bond1 = row[4] ? row[4].toString() : "";
            const bond2 = row[5] ? row[5].toString() : "";
            const err = +row[6];

            parsed.push({
                inputdate: dateVal,
                context1: context1,
                isin1: isin1,
                isin2: isin2,
                bond1: bond1,
                bond2: bond2,
                error: err
            });
        });

        // Log date range for debugging
        if (parsed.length > 0) {
            const minDate = d3.min(parsed, d => d.inputdate);
            const maxDate = d3.max(parsed, d => d.inputdate);
            console.log("Date range:", {
                min: minDate?.toISOString(),
                max: maxDate?.toISOString(),
                totalPoints: parsed.length
            });
        }

        parsed.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
        this.allData = parsed;

        // Use rows where context1 is "P_VALUE" (normalized) to populate the dropdown.
        const pValueRows = parsed.filter(d => d.context1.trim().toUpperCase() === "P_VALUE");
        console.log("P_VALUE Rows:", pValueRows);
        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }

        // Find the latest date (by day) among P_VALUE rows.
        const maxDateMs = d3.max(pValueRows, d => d.inputdate.getTime())!;
        const maxDateObj = new Date(maxDateMs);
        console.log("Latest P_VALUE Date:", maxDateObj);
        const latestRows = pValueRows.filter(d => d.inputdate.toDateString() === maxDateObj.toDateString());
        console.log("Latest P_VALUE Rows (same day):", latestRows);

        // Build unique pairs from latestRows using isin1 and isin2.
        const pairSet = new Set<string>();
        latestRows.forEach(row => {
            const pairKey = `${row.isin1}||${row.isin2}`;
            pairSet.add(pairKey);
        });
        const uniquePairs = Array.from(pairSet);
        console.log("Unique Pairs:", uniquePairs);

        // Populate the dropdown.
        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pk => {
            const opt = document.createElement("option");
            opt.value = pk;
            opt.text = pk;
            this.dropdownPairs.appendChild(opt);
        });
        if (uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }

        // Update the chart.
        this.updateChartsInner();
    }

    private updateChartsInner() {
        if (this.dropdownPairs.options.length === 0) return;
        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        const [selectedIsin1, selectedIsin2] = selectedPair.split("||");
        console.log("Selected Pair:", selectedIsin1, selectedIsin2);

        // Filter rows with context1 === "ERROR" (normalized).
        const errorRows = this.allData.filter(d => d.context1.trim().toUpperCase() === "ERROR");
        console.log("ERROR Rows:", errorRows);

        // Build maps for each bond (using day-level keys).
        const mapBond1 = new Map<string, number>();
        errorRows.filter(d => d.isin1.trim() === selectedIsin1.trim())
            .forEach(d => {
                const key = d.inputdate.toDateString();
                mapBond1.set(key, d.error);
            });
        const mapBond2 = new Map<string, number>();
        errorRows.filter(d => d.isin1.trim() === selectedIsin2.trim())
            .forEach(d => {
                const key = d.inputdate.toDateString();
                mapBond2.set(key, d.error);
            });
        console.log("Bond1 Map:", mapBond1);
        console.log("Bond2 Map:", mapBond2);

        // Compute the difference series (for overlapping days).
        let diffSeries: DiffPoint[] = [];
        mapBond1.forEach((val1, key) => {
            if (mapBond2.has(key)) {
                const val2 = mapBond2.get(key)!;
                diffSeries.push({ inputdate: new Date(key), diff: val1 - val2 });
            }
        });
        diffSeries.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
        console.log("Difference Series:", diffSeries);
        this.diffSeries = diffSeries;

        if (diffSeries.length < 2) {
            console.log("Not enough overlapping data for difference series.");
            this.renderChart(false);
            return;
        }

        // Apply ADF test on the difference series.
        const diffs = diffSeries.map(d => d.diff);
        const adfPassed = this.performADFTest(diffs);
        this.diffSeriesStationary = adfPassed;
        console.log("ADF Test Stationary?", adfPassed);

        // Render Chart 1.
        this.renderChart(adfPassed);
    }

    private performADFTest(data: number[]): boolean {
        if (data.length < 3) return false;
        let dX: number[] = [];
        let lagX: number[] = [];
        for (let i = 1; i < data.length; i++) {
            dX.push(data[i] - data[i - 1]);
            lagX.push(data[i - 1]);
        }
        const m = dX.length;
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        let num = 0, den = 0;
        for (let i = 0; i < m; i++) {
            num += (lagX[i] - meanLag) * (dX[i] - meanDX);
            den += Math.pow(lagX[i] - meanLag, 2);
        }
        const slope = num / den;
        let ssr = 0;
        for (let i = 0; i < m; i++) {
            const pred = slope * lagX[i];
            ssr += Math.pow(dX[i] - pred, 2);
        }
        const s2 = ssr / (m - 2);
        const se = Math.sqrt(s2 / den);
        const tStat = slope / se;
        console.log("ADF t-statistic:", tStat);
        return tStat < -3;
    }

    private calculateOUParameters(diffValues: number[], dates: Date[]): { 
        lambda: number, 
        mu: number, 
        sigma: number,
        forecastPoints: DiffPoint[],
        upperBoundPoints: DiffPoint[],
        lowerBoundPoints: DiffPoint[]
    } {
        const n = diffValues.length - 1;
        const diffMean = d3.mean(diffValues)!;
        
        // Calculate alpha
        let num = 0, den = 0;
        for (let i = 0; i < n; i++) {
            num += (diffValues[i + 1] - diffMean) * (diffValues[i] - diffMean);
            den += Math.pow(diffValues[i] - diffMean, 2);
        }
        let alphaHat = num / den;
        alphaHat = Math.max(Math.min(alphaHat, 0.9999999), -0.9999999);

        // Calculate time parameters
        const firstTime = dates[0].getTime();
        const lastTime = dates[dates.length - 1].getTime();
        const delta = (lastTime - firstTime) / n;
        const deltaDays = delta / (1000 * 60 * 60 * 24);

        // Calculate OU parameters
        const lambdaHat = -Math.log(alphaHat) / deltaDays;
        
        // Calculate mu
        let sumResidual = 0;
        for (let i = 0; i < n; i++) {
            sumResidual += diffValues[i + 1] - alphaHat * diffValues[i];
        }
        const muHat = sumResidual / (n * (1 - alphaHat));

        // Calculate sigma
        let sumSq = 0;
        for (let i = 0; i < n; i++) {
            const r = diffValues[i + 1] - alphaHat * diffValues[i] - (1 - alphaHat) * muHat;
            sumSq += r * r;
        }
        const sigmaSqHat = (2 * lambdaHat) / (1 - alphaHat * alphaHat) * (1 / n) * sumSq;
        const sigmaHat = Math.sqrt(Math.max(sigmaSqHat, 0));

        // Apply slider scaling
        const lambdaFactor = parseFloat(this.lambdaSlider.value);
        const sigmaFactor = parseFloat(this.sigmaSlider.value);
        const newLambda = lambdaHat * lambdaFactor;
        const newSigma = sigmaHat * sigmaFactor;
        const alpha = Math.exp(-newLambda * deltaDays);

        // Generate forecast points
        const lastDiff = diffValues[diffValues.length - 1];
        const forecastSteps = 30;
        let forecastPoints: DiffPoint[] = [];
        let upperBoundPoints: DiffPoint[] = [];
        let lowerBoundPoints: DiffPoint[] = [];

        // Start forecast from the last historical point
        for (let i = 0; i <= forecastSteps; i++) {
            const nextDate = new Date(lastTime + i * delta);
            const meanForecast = muHat + (lastDiff - muHat) * Math.pow(alpha, i);
            const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
            const stdDev = Math.sqrt(varForecast);
            
            forecastPoints.push({ inputdate: nextDate, diff: meanForecast });
            upperBoundPoints.push({ inputdate: nextDate, diff: meanForecast + 1.96 * stdDev });
            lowerBoundPoints.push({ inputdate: nextDate, diff: meanForecast - 1.96 * stdDev });
        }

        return {
            lambda: newLambda,
            mu: muHat,
            sigma: newSigma,
            forecastPoints,
            upperBoundPoints,
            lowerBoundPoints
        };
    }

    private renderChart(isStationary: boolean) {
        // Clear previous chart
        this.svg.selectAll("*").remove();

        // Set up dimensions
        const width = this.currentViewport.width;
        const height = this.currentViewport.height;
        this.svg.attr("width", width).attr("height", height);

        // Define margins
        const margin = { top: 40, right: 30, bottom: 60, left: 50 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // Create main chart group
        const g = this.svg.append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        // Check for data
        if (this.diffSeries.length < 1) {
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight / 2)
                .attr("text-anchor", "middle")
                .attr("fill", "red")
                .style("font-size", "14px")
                .text("No data to display.");
            return;
        }

        // Declare scales
        let xScale: d3.ScaleTime<number, number>;
        let yScale: d3.ScaleLinear<number, number>;

        // Create line generator
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        if (isStationary) {
            // Calculate OU parameters and forecast
            const ouResults = this.calculateOUParameters(
                this.diffSeries.map(d => d.diff),
                this.diffSeries.map(d => d.inputdate)
            );

            // Combine historical and forecast data for scales
            const allX = this.diffSeries.map(d => d.inputdate)
                .concat(ouResults.forecastPoints.map(d => d.inputdate));
            const allY = this.diffSeries.map(d => d.diff)
                .concat(ouResults.forecastPoints.map(d => d.diff))
                .concat(ouResults.upperBoundPoints.map(d => d.diff))
                .concat(ouResults.lowerBoundPoints.map(d => d.diff));

            // Create scales with combined data
            xScale = d3.scaleTime()
                .domain([d3.min(allX) as Date, d3.max(allX) as Date])
                .range([0, innerWidth]);

            yScale = d3.scaleLinear()
                .domain([d3.min(allY) as number, d3.max(allY) as number])
                .range([innerHeight, 0])
                .nice();

            // Draw forecast confidence bands (dashed grey)
            g.append("path")
                .datum(ouResults.lowerBoundPoints)
                .attr("fill", "none")
                .attr("stroke", "grey")
                .attr("stroke-width", 1)
                .style("stroke-dasharray", "3,3")
                .attr("d", lineGen);

            g.append("path")
                .datum(ouResults.upperBoundPoints)
                .attr("fill", "none")
                .attr("stroke", "grey")
                .attr("stroke-width", 1)
                .style("stroke-dasharray", "3,3")
                .attr("d", lineGen);

            // Draw forecast mean line (solid orange)
            g.append("path")
                .datum(ouResults.forecastPoints)
                .attr("fill", "none")
                .attr("stroke", "orange")
                .attr("stroke-width", 2)
                .style("stroke-dasharray", "0")
                .attr("d", lineGen);

            // Draw historical data line (solid, color #00818F)
            g.append("path")
                .datum(this.diffSeries)
                .attr("fill", "none")
                .attr("stroke", "#00818F")
                .attr("stroke-width", 2)
                .style("stroke-dasharray", "0")
                .attr("d", lineGen);

            // Add status text
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("fill", "green")
                .style("font-size", "12px")
                .text("ADF passed: Series stationary. OU applied.");
        } else {
            // Create scales for historical data only
            xScale = d3.scaleTime()
                .domain([
                    d3.min(this.diffSeries, d => d.inputdate)!,
                    d3.max(this.diffSeries, d => d.inputdate)!
                ])
                .range([0, innerWidth]);

            yScale = d3.scaleLinear()
                .domain([
                    d3.min(this.diffSeries, d => d.diff) as number,
                    d3.max(this.diffSeries, d => d.diff) as number
                ])
                .range([innerHeight, 0])
                .nice();

            // Draw historical data line (solid, color #00818F)
            g.append("path")
                .datum(this.diffSeries)
                .attr("fill", "none")
                .attr("stroke", "#00818F")
                .attr("stroke-width", 2)
                .style("stroke-dasharray", "0")
                .attr("d", lineGen);

            // Add status text
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("fill", "red")
                .style("font-size", "12px")
                .style("font-family", "sans-serif")
                .style("font-weight", "bold")
                .text("ADF failed: Series non-stationary. OU not applied.");
        }

        // Dynamically determine tick count
        const tickCount = Math.max(2, Math.floor(innerWidth / 80));
        
        // Create and add x-axis with improved formatting
        const xAxis = d3.axisBottom(xScale)
            .ticks(tickCount)
            .tickFormat(d3.timeFormat("%b %d, %Y"));
            
        const xAxisGroup = g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(xAxis);

        // Rotate labels only for narrow charts
        if (innerWidth < 300) {
            xAxisGroup.selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end")
                .style("font-size", "10px")
                .style("fill", "#666")
                .attr("dy", "0.71em")
                .attr("dx", "-0.71em");
        } else {
            xAxisGroup.selectAll("text")
                .style("font-size", "10px")
                .style("fill", "#666");
        }

        // Add y-axis
        g.append("g")
            .call(d3.axisLeft(yScale))
            .selectAll("text")
            .style("font-size", "10px")
            .style("fill", "#666");
    }
}
