"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

/**
 * Data schema:
 *   inputdate, context1, isin1, isin2, Bond1, Bond2, Error
 */
interface DataRow {
  inputdate: Date;
  context1: string;
  isin1: string;
  isin2: string;
  bond1: string;
  bond2: string;
  error: number;
}

/** For the difference series (Error for Bond1 minus Error for Bond2) */
interface DiffPoint {
  x: Date;
  y: number;
}

export class Visual implements IVisual {
  private target: HTMLElement;
  private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;

  // Chart margins.
  private margin = { top: 20, right: 30, bottom: 50, left: 50 };

  // The processed difference series (historical data).
  private data: DiffPoint[] = [];
  private lambdaHat: number = 0;
  private muHat: number = 0;
  private sigmaHat: number = 0;
  private delta: number = 1;  // time step in ms

  // OU scaling sliders.
  private lambdaSlider: HTMLInputElement;
  private sigmaSlider: HTMLInputElement;

  // Dropdown for pair selection (formatted as "isin1||isin2").
  private dropdownPairs: HTMLSelectElement;

  // Current viewport dimensions.
  private currentViewport: { width: number, height: number } = { width: 600, height: 300 };

  // Flag indicating if the diff series passed the ADF test.
  private diffSeriesStationary: boolean = false;

  // All parsed data.
  private allData: DataRow[] = [];

  constructor(options: VisualConstructorOptions) {
    this.target = options.element;
    this.target.innerHTML = "";

    // Create container for controls.
    const controlContainer = document.createElement("div");
    controlContainer.id = "control-container";
    controlContainer.innerHTML = `
      <div id="dropdown-container">
          <label for="pairDropdown">Select Pair (isin1||isin2):</label>
          <select id="pairDropdown"></select>
      </div>
      <div id="slider-container">
          <div>
              <label for="lambdaSlider">Lambda Factor:</label>
              <input id="lambdaSlider" type="range" min="0.5" max="2.0" step="0.01" value="1.0">
              <span id="lambdaValue">1.0</span>
          </div>
          <div>
              <label for="sigmaSlider">Sigma Factor:</label>
              <input id="sigmaSlider" type="range" min="0.5" max="2.0" step="0.01" value="1.0">
              <span id="sigmaValue">1.0</span>
          </div>
      </div>
    `;
    this.target.appendChild(controlContainer);

    // Get control references.
    this.dropdownPairs = document.getElementById("pairDropdown") as HTMLSelectElement;
    this.lambdaSlider = document.getElementById("lambdaSlider") as HTMLInputElement;
    this.sigmaSlider = document.getElementById("sigmaSlider") as HTMLInputElement;

    // Attach event listeners.
    this.dropdownPairs.addEventListener("change", () => {
      console.log("Dropdown changed. Selected pair:", this.dropdownPairs.value);
      this.updateChartInner();
    });
    this.lambdaSlider.addEventListener("input", () => {
      (document.getElementById("lambdaValue") as HTMLElement).innerText = this.lambdaSlider.value;
      this.updateChartInner();
    });
    this.sigmaSlider.addEventListener("input", () => {
      (document.getElementById("sigmaValue") as HTMLElement).innerText = this.sigmaSlider.value;
      this.updateChartInner();
    });

    // Create container for Chart 1.
    const chartContainer = document.createElement("div");
    chartContainer.id = "chart1";
    this.target.appendChild(chartContainer);

    // Create the SVG container.
    this.svg = d3.select(chartContainer)
      .append("svg")
      .classed("ou-estimation-visual", true);

    // Create a tooltip div.
    if (d3.select(this.target).select("div.tooltip").empty()) {
      d3.select(this.target)
        .append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("pointer-events", "none")
        .style("opacity", "0")
        .style("background", "#fff")
        .style("border", "1px solid #ccc")
        .style("padding", "5px")
        .style("border-radius", "3px")
        .style("font-size", "12px");
    }
  }

  public update(options: VisualUpdateOptions) {
    const dataView: DataView = options.dataViews && options.dataViews[0];
    if (!dataView || !dataView.table) return;
    this.currentViewport = options.viewport || { width: 600, height: 300 };

    // Reset sliders to default.
    this.lambdaSlider.value = "1.0";
    this.sigmaSlider.value = "1.0";
    document.getElementById("lambdaValue")!.innerText = "1.0";
    document.getElementById("sigmaValue")!.innerText = "1.0";

    const rows = dataView.table.rows;
    if (!rows || rows.length < 2) return;

    // Parse all rows.
    let parsed: DataRow[] = [];
    rows.forEach((row: any[]) => {
      const dateVal = new Date(row[0]);
      const context1 = row[1] ? row[1].toString() : "";
      const isin1 = row[2] ? row[2].toString() : "";
      const isin2 = row[3] ? row[3].toString() : "";
      const bond1 = row[4] ? row[4].toString() : "";
      const bond2 = row[5] ? row[5].toString() : "";
      const err = +row[6];
      parsed.push({
        inputdate: dateVal,
        context1: context1,
        isin1: isin1,
        isin2: isin2,
        bond1: bond1,
        bond2: bond2,
        error: err
      });
    });
    console.log("Parsed Data (all rows):", parsed);
    parsed.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
    this.allData = parsed;

    // Populate dropdown from rows with context1 === "P_VALUE" (normalized).
    const pValueRows = parsed.filter(d => d.context1.trim().toUpperCase() === "P_VALUE");
    console.log("P_VALUE Rows:", pValueRows);
    if (pValueRows.length === 0) {
      this.dropdownPairs.options.length = 0;
      this.svg.selectAll("*").remove();
      return;
    }
    // Find latest date (by day) among P_VALUE rows.
    const maxDateMs = d3.max(pValueRows, d => d.inputdate.getTime())!;
    const maxDateObj = new Date(maxDateMs);
    console.log("Latest P_VALUE Date:", maxDateObj);
    const latestRows = pValueRows.filter(d => d.inputdate.toDateString() === maxDateObj.toDateString());
    console.log("Latest P_VALUE Rows (same day):", latestRows);
    const pairSet = new Set<string>();
    latestRows.forEach(row => {
      const pairKey = `${row.isin1}||${row.isin2}`;
      pairSet.add(pairKey);
    });
    const uniquePairs = Array.from(pairSet);
    console.log("Unique Pairs:", uniquePairs);
    this.dropdownPairs.options.length = 0;
    uniquePairs.forEach(pk => {
      const opt = document.createElement("option");
      opt.value = pk;
      opt.text = pk;
      this.dropdownPairs.appendChild(opt);
    });
    if (uniquePairs.length > 0) {
      this.dropdownPairs.value = uniquePairs[0];
    }

    this.updateChartInner();
  }

  /**
   * updateChartInner() filters rows where context1 === "ERROR" (normalized),
   * builds day-level error series for each bond (using isin1),
   * computes the difference series (Error for Bond1 minus Error for Bond2),
   * applies the ADF test, and sets this.data.
   */
  private updateChartInner() {
    if (this.dropdownPairs.options.length === 0) return;
    const selectedPair = this.dropdownPairs.value;
    if (!selectedPair) return;
    const [selectedIsin1, selectedIsin2] = selectedPair.split("||");
    console.log("Selected Pair:", selectedIsin1, selectedIsin2);

    // Filter rows with context1 === "ERROR".
    const errorRows = this.allData.filter(d => d.context1.trim().toUpperCase() === "ERROR");
    console.log("ERROR Rows:", errorRows);

    // Build day-level maps for each bond.
    const mapBond1 = new Map<string, number>();
    errorRows.filter(d => d.isin1.trim() === selectedIsin1.trim())
      .forEach(d => {
        const key = d.inputdate.toDateString();
        mapBond1.set(key, d.error);
      });
    const mapBond2 = new Map<string, number>();
    errorRows.filter(d => d.isin1.trim() === selectedIsin2.trim())
      .forEach(d => {
        const key = d.inputdate.toDateString();
        mapBond2.set(key, d.error);
      });
    console.log("Bond1 Map:", mapBond1);
    console.log("Bond2 Map:", mapBond2);

    // Compute difference series (for overlapping days).
    let diffSeries: DiffPoint[] = [];
    mapBond1.forEach((val1, key) => {
      if (mapBond2.has(key)) {
        const val2 = mapBond2.get(key)!;
        diffSeries.push({ x: new Date(key), y: val1 - val2 });
      }
    });
    diffSeries.sort((a, b) => a.x.getTime() - b.x.getTime());
    console.log("Difference Series:", diffSeries);
    this.data = diffSeries;
    if (diffSeries.length < 2) {
      console.log("Not enough overlapping data for difference series.");
      this.renderChart({ viewport: this.currentViewport });
      return;
    }

    // Apply ADF test.
    const diffs = diffSeries.map(d => d.y);
    const adfPassed = this.performADFTest(diffs);
    this.diffSeriesStationary = adfPassed;
    console.log("ADF Test Stationary?", adfPassed);

    this.renderChart({ viewport: this.currentViewport });
  }

  /**
   * A basic ADF test (without extra lags) on a numeric array.
   * Returns true if the t-statistic is less than -3.
   */
  private performADFTest(data: number[]): boolean {
    if (data.length < 3) return false;
    let dX: number[] = [];
    let lagX: number[] = [];
    for (let i = 1; i < data.length; i++) {
      dX.push(data[i] - data[i - 1]);
      lagX.push(data[i - 1]);
    }
    const m = dX.length;
    const meanLag = d3.mean(lagX)!;
    const meanDX = d3.mean(dX)!;
    let num = 0, den = 0;
    for (let i = 0; i < m; i++) {
      num += (lagX[i] - meanLag) * (dX[i] - meanDX);
      den += Math.pow(lagX[i] - meanLag, 2);
    }
    const slope = num / den;
    let ssr = 0;
    for (let i = 0; i < m; i++) {
      const pred = slope * lagX[i];
      ssr += Math.pow(dX[i] - pred, 2);
    }
    const s2 = ssr / (m - 2);
    const se = Math.sqrt(s2 / den);
    const tStat = slope / se;
    console.log("ADF t-statistic:", tStat);
    return tStat < -3;
  }

  /**
   * Renders the chart exactly as in the provided sample code.
   * Uses this.data (array of { x: Date, y: number }) for historical data.
   */
  private renderChart(options?: VisualUpdateOptions) {
    if (!this.data || this.data.length < 2) return;
    const viewport = options?.viewport || this.currentViewport;
    const lambdaSlider = document.getElementById("lambdaSlider") as HTMLInputElement;
    const sigmaSlider = document.getElementById("sigmaSlider") as HTMLInputElement;
    const lambdaFactor = parseFloat(lambdaSlider.value);
    const sigmaFactor = parseFloat(sigmaSlider.value);
    const newLambda = this.lambdaHat * lambdaFactor;
    const newSigma = this.sigmaHat * sigmaFactor;
    const deltaDays = this.delta / (1000 * 60 * 60 * 24);
    const alpha = Math.exp(-newLambda * deltaDays);

    this.svg.selectAll("*").remove();
    const width = viewport.width || 300;
    const height = viewport.height || 200;
    this.svg.attr("width", width).attr("height", height);
    const innerWidth = width - this.margin.left - this.margin.right;
    const innerHeight = height - this.margin.top - this.margin.bottom;

    const g = this.svg.append("g")
      .attr("transform", `translate(${this.margin.left}, ${this.margin.top})`);

    // Forecast 50 steps ahead.
    const forecastSteps = 50;
    const lastPoint = this.data[this.data.length - 1];
    let forecastPoints: { x: Date, mean: number, lower: number, upper: number }[] = [];
    for (let i = 1; i <= forecastSteps; i++) {
      const nextX = new Date(lastPoint.x.getTime() + i * this.delta);
      const mean = this.muHat + (lastPoint.y - this.muHat) * Math.pow(alpha, i);
      const varForecast = (newSigma * newSigma) / (2 * newLambda) * (1 - Math.pow(alpha, 2 * i));
      const stdDev = Math.sqrt(varForecast);
      const lower = mean - 1.96 * stdDev;
      const upper = mean + 1.96 * stdDev;
      forecastPoints.push({ x: nextX, mean, lower, upper });
    }
    const forecastMeanLine = forecastPoints.map(d => ({ x: d.x, y: d.mean }));
    const forecastLowerLine = forecastPoints.map(d => ({ x: d.x, y: d.lower }));
    const forecastUpperLine = forecastPoints.map(d => ({ x: d.x, y: d.upper }));

    // Combine historical and forecast data for scales.
    const allX = this.data.map(d => d.x).concat(forecastMeanLine.map(d => d.x));
    const allY = this.data.map(d => d.y)
      .concat(forecastMeanLine.map(d => d.y))
      .concat(forecastLowerLine.map(d => d.y))
      .concat(forecastUpperLine.map(d => d.y));

    const xScale = d3.scaleTime()
      .domain([d3.min(allX) as Date, d3.max(allX) as Date])
      .range([0, innerWidth]);
    const yScale = d3.scaleLinear()
      .domain([d3.min(allY) as number, d3.max(allY) as number])
      .range([innerHeight, 0])
      .nice();

    // Dynamically determine tick count.
    const tickCount = Math.max(2, Math.floor(innerWidth / 80));
    const xAxis = d3.axisBottom(xScale)
      .ticks(tickCount)
      .tickFormat(d3.timeFormat("%b %d, %Y"));
    const xAxisGroup = g.append("g")
      .attr("transform", `translate(0, ${innerHeight})`)
      .call(xAxis);
    if(innerWidth < 300) {
      xAxisGroup.selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end");
    }
    g.append("g").call(d3.axisLeft(yScale));

    const lineGen = d3.line<{ x: Date, y: number }>()
      .x(d => xScale(d.x))
      .y(d => yScale(d.y))
      .curve(d3.curveMonotoneX);

    // Draw forecast confidence bands (dashed grey).
    g.append("path")
      .datum(forecastLowerLine)
      .attr("fill", "none")
      .attr("stroke", "grey")
      .attr("stroke-width", 1)
      .style("stroke-dasharray", "3,3")
      .attr("d", lineGen);
    g.append("path")
      .datum(forecastUpperLine)
      .attr("fill", "none")
      .attr("stroke", "grey")
      .attr("stroke-width", 1)
      .style("stroke-dasharray", "3,3")
      .attr("d", lineGen);

    // Draw forecast mean line (solid orange).
    g.append("path")
      .datum(forecastMeanLine)
      .attr("fill", "none")
      .attr("stroke", "orange")
      .attr("stroke-width", 2)
      .style("stroke-dasharray", "0")
      .attr("d", lineGen);

    // Draw historical data line (solid, color #00818F).
    g.append("path")
      .datum(this.data)
      .attr("fill", "none")
      .attr("stroke", "#00818F")
      .attr("stroke-width", 2)
      .style("stroke-dasharray", "0")
      .attr("d", lineGen);

    // Invisible circles for tooltips (historical).
    g.selectAll("circle.historical")
      .data(this.data)
      .enter()
      .append("circle")
      .attr("class", "historical")
      .attr("cx", d => xScale(d.x))
      .attr("cy", d => yScale(d.y))
      .attr("r", 5)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("pointer-events", "all")
      .on("mouseover", (event, d) => {
          d3.select(this.target).select("div.tooltip")
            .transition().duration(200).style("opacity", 0.9);
          d3.select(this.target).select("div.tooltip")
            .html(`Date: ${d.x.toLocaleDateString()}<br>Value: ${d.y.toFixed(2)}`)
            .style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
      })
      .on("mousemove", (event, d) => {
          d3.select(this.target).select("div.tooltip")
            .style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
      })
      .on("mouseout", () => {
          d3.select(this.target).select("div.tooltip")
            .transition().duration(500).style("opacity", 0);
      });

    // Invisible circles for tooltips (forecast).
    g.selectAll("circle.forecast")
      .data(forecastMeanLine)
      .enter()
      .append("circle")
      .attr("class", "forecast")
      .attr("cx", d => xScale(d.x))
      .attr("cy", d => yScale(d.y))
      .attr("r", 5)
      .attr("fill", "transparent")
      .attr("stroke", "none")
      .style("pointer-events", "all")
      .on("mouseover", (event, d) => {
          d3.select(this.target).select("div.tooltip")
            .transition().duration(200).style("opacity", 0.9);
          d3.select(this.target).select("div.tooltip")
            .html(`Date: ${d.x.toLocaleDateString()}<br>Mean: ${d.y.toFixed(2)}`)
            .style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
      })
      .on("mousemove", (event, d) => {
          d3.select(this.target).select("div.tooltip")
            .style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
      })
      .on("mouseout", () => {
          d3.select(this.target).select("div.tooltip")
            .transition().duration(500).style("opacity", 0);
      });

    // Display parameter estimates above the chart.
    g.append("text")
      .attr("x", 10)
      .attr("y", -10)
      .attr("fill", "#333")
      .style("font-size", "12px")
      .text(`μ = ${this.muHat.toFixed(2)}, λ = ${this.lambdaHat.toFixed(2)} (×${lambdaFactor}), σ = ${this.sigmaHat.toFixed(2)} (×${sigmaFactor})`);
  }
}
