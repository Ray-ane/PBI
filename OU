"use strict";
import "./../style/visual.less";
import * as d3 from "d3";
import powerbiVisualsApi from "powerbi-visuals-api";
import IVisual = powerbiVisualsApi.extensibility.visual.IVisual;
import VisualConstructorOptions = powerbiVisualsApi.extensibility.visual.VisualConstructorOptions;
import VisualUpdateOptions = powerbiVisualsApi.extensibility.visual.VisualUpdateOptions;
import DataView = powerbiVisualsApi.DataView;

/**
 * New Data Schema:
 * - inputdate: Date
 * - context1: string
 * - isin1: string
 * - isin2: string
 * - bond1: string
 * - bond2: string
 * - error: number
 */
interface DataRow {
    inputdate: Date;
    context1: string;
    isin1: string;
    isin2: string;
    bond1: string;
    bond2: string;
    error: number;
}

/** Interface for difference series point */
interface DiffPoint {
    inputdate: Date;
    diff: number;
}

export class Visual implements IVisual {
    private target: HTMLElement;
    // Single dropdown for pair selection (isin1||isin2)
    private dropdownPairs: HTMLSelectElement;
    // All data from Power BI
    private allData: DataRow[] = [];
    // The difference series computed for the selected pair
    private diffSeries: DiffPoint[] = [];
    // Chart margins
    private margin = { top: 20, right: 30, bottom: 50, left: 50 };
    // OU parameters (computed from diff series if stationarity holds)
    private lambdaHat: number = 0;
    private muHat: number = 0;
    private sigmaHat: number = 0;
    // SVG container for the chart
    private svg: d3.Selection<SVGSVGElement, unknown, null, undefined>;
    // Current viewport dimensions
    private currentViewport: { width: number, height: number } = { width: 300, height: 200 };
    // Flag for stationarity (result of ADF test)
    private isStationary: boolean = false;

    constructor(options: VisualConstructorOptions) {
        this.target = options.element;
        this.target.innerHTML = "";

        // Create control container with a single dropdown.
        const controlContainer = document.createElement("div");
        controlContainer.id = "control-container";
        controlContainer.innerHTML = `
            <label for="pairDropdown">Select Pair (isin1||isin2):</label>
            <select id="pairDropdown"></select>
        `;
        this.target.appendChild(controlContainer);

        this.dropdownPairs = document.getElementById("pairDropdown") as HTMLSelectElement;
        this.dropdownPairs.addEventListener("change", () => {
            console.log("Dropdown changed. Selected pair:", this.dropdownPairs.value);
            this.computeDiffAndRender();
        });

        // Create the SVG container for the chart.
        this.svg = d3.select(this.target)
            .append("svg")
            .classed("diff-chart", true);
    }

    public update(options: VisualUpdateOptions) {
        const dataView: DataView = options.dataViews && options.dataViews[0];
        if (!dataView || !dataView.table) return;
        this.currentViewport = options.viewport || { width: 300, height: 200 };

        // Parse the dataset.
        const rows = dataView.table.rows;
        if (!rows || rows.length === 0) return;

        let parsed: DataRow[] = [];
        rows.forEach((row: any[]) => {
            const dateVal = new Date(row[0]);
            const context1 = row[1]?.toString() || "";
            const isin1 = row[2]?.toString() || "";
            const isin2 = row[3]?.toString() || "";
            const bond1 = row[4]?.toString() || "";
            const bond2 = row[5]?.toString() || "";
            const err = +row[6];

            if (!isNaN(dateVal.getTime()) && context1 && isin1 && isin2 && bond1 && bond2 && !isNaN(err)) {
                parsed.push({
                    inputdate: dateVal,
                    context1,
                    isin1,
                    isin2,
                    bond1,
                    bond2,
                    error: err
                });
            }
        });
        console.log("Parsed Data:", parsed);
        parsed.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
        this.allData = parsed;

        // Get rows where context1 is "P_VALUE" for pair extraction.
        const pValueRows = parsed.filter(d => d.context1 === "P_VALUE");
        console.log("P_VALUE Rows:", pValueRows);
        if (pValueRows.length === 0) {
            this.dropdownPairs.options.length = 0;
            this.svg.selectAll("*").remove();
            return;
        }
        const latestDate = d3.max(pValueRows, d => d.inputdate)!;
        console.log("Latest P_VALUE Date:", latestDate);
        const latestRows = pValueRows.filter(d => d.inputdate.toDateString() === latestDate.toDateString());
        console.log("Latest P_VALUE Rows:", latestRows);

        // Build unique pairs (using isin1 and isin2) from latestRows.
        const pairSet = new Set<string>();
        latestRows.forEach(row => {
            const pairKey = `${row.isin1}||${row.isin2}`;
            pairSet.add(pairKey);
        });
        const uniquePairs = Array.from(pairSet);
        console.log("Unique Pairs:", uniquePairs);

        // Populate dropdown.
        this.dropdownPairs.options.length = 0;
        uniquePairs.forEach(pk => {
            const opt = document.createElement("option");
            opt.value = pk;
            opt.text = pk;
            this.dropdownPairs.appendChild(opt);
        });
        if(uniquePairs.length > 0) {
            this.dropdownPairs.value = uniquePairs[0];
        }

        // Compute difference series and render.
        this.computeDiffAndRender();
    }

    /**
     * Compute the difference time series for the selected pair.
     * Performs day-level matching (using toDateString()).
     */
    private computeDiffAndRender() {
        if (!this.allData || this.allData.length === 0) return;
        if (this.dropdownPairs.options.length === 0) return;

        const selectedPair = this.dropdownPairs.value;
        if (!selectedPair) return;
        const [selectedIsin1, selectedIsin2] = selectedPair.split("||");
        console.log("Selected Pair:", selectedIsin1, selectedIsin2);

        // Filter rows where context1 is "ERROR"
        const errorRows = this.allData.filter(d => d.context1 === "ERROR");
        console.log("ERROR Rows:", errorRows);

        // Build maps for each bond using day-level key.
        const mapBond1 = new Map<string, number>(); // key = date.toDateString()
        errorRows.filter(d => d.isin1 === selectedIsin1)
            .forEach(d => {
                const key = d.inputdate.toDateString();
                mapBond1.set(key, d.error);
            });
        const mapBond2 = new Map<string, number>();
        errorRows.filter(d => d.isin1 === selectedIsin2)
            .forEach(d => {
                const key = d.inputdate.toDateString();
                mapBond2.set(key, d.error);
            });
        console.log("Bond1 Map:", mapBond1);
        console.log("Bond2 Map:", mapBond2);

        // Compute the difference series using the intersection of dates (by day).
        let diffSeries: DiffPoint[] = [];
        mapBond1.forEach((val1, key) => {
            if (mapBond2.has(key)) {
                const val2 = mapBond2.get(key)!;
                diffSeries.push({
                    inputdate: new Date(key),
                    diff: val1 - val2
                });
            }
        });
        diffSeries.sort((a, b) => a.inputdate.getTime() - b.inputdate.getTime());
        console.log("Difference Series:", diffSeries);
        this.diffSeries = diffSeries;

        if(diffSeries.length < 2) {
            console.log("Not enough overlapping data for difference series.");
            this.renderDiffChart(false);
            return;
        }

        // Apply ADF test on the difference values.
        const diffs = diffSeries.map(d => d.diff);
        this.isStationary = this.performADFTest(diffs);
        console.log("ADF Test Stationary?", this.isStationary);

        // If stationary, OU process can be applied. (You can add further OU estimation/forecast logic here.)
        // For now, we simply render the difference chart with a message if non-stationary.
        this.renderDiffChart(this.isStationary);
    }

    /**
     * A basic ADF test implementation (no extra lags).
     * Returns true if the t-statistic < -3 (stationary).
     */
    private performADFTest(data: number[]): boolean {
        if (data.length < 3) return false;
        let dX: number[] = [];
        let lagX: number[] = [];
        for (let i = 1; i < data.length; i++) {
            dX.push(data[i] - data[i-1]);
            lagX.push(data[i-1]);
        }
        const m = dX.length;
        const meanLag = d3.mean(lagX)!;
        const meanDX = d3.mean(dX)!;
        let num = 0, den = 0;
        for (let i = 0; i < m; i++) {
            num += (lagX[i] - meanLag) * (dX[i] - meanDX);
            den += Math.pow(lagX[i] - meanLag, 2);
        }
        const slope = num / den;
        let ssr = 0;
        for (let i = 0; i < m; i++) {
            const pred = slope * lagX[i];
            ssr += Math.pow(dX[i] - pred, 2);
        }
        const s2 = ssr / (m - 2);
        const se = Math.sqrt(s2 / den);
        const tStat = slope / se;
        console.log("ADF t-statistic:", tStat);
        return tStat < -3;
    }

    /**
     * Renders the difference chart. If OU process was applied (isStationary true),
     * you could add forecast logic. For now, we simply draw the historical difference line.
     */
    private renderDiffChart(isStationary: boolean) {
        // Clear the SVG.
        this.svg.selectAll("*").remove();

        const width = this.currentViewport.width || 300;
        const height = this.currentViewport.height || 200;
        this.svg.attr("width", width).attr("height", height);
        const innerWidth = width - this.margin.left - this.margin.right;
        const innerHeight = height - this.margin.top - this.margin.bottom;

        const g = this.svg.append("g")
            .attr("transform", `translate(${this.margin.left}, ${this.margin.top})`);

        // Build x scale from diffSeries dates.
        const xScale = d3.scaleTime()
            .domain([this.diffSeries[0].inputdate, this.diffSeries[this.diffSeries.length-1].inputdate])
            .range([0, innerWidth]);

        // Build y scale from diff values.
        const allDiffs = this.diffSeries.map(d => d.diff);
        const yScale = d3.scaleLinear()
            .domain([d3.min(allDiffs) as number, d3.max(allDiffs) as number])
            .range([innerHeight, 0])
            .nice();

        // Draw axes.
        g.append("g")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%b %d, %Y")));
        g.append("g")
            .call(d3.axisLeft(yScale));

        // Create a line generator.
        const lineGen = d3.line<DiffPoint>()
            .x(d => xScale(d.inputdate))
            .y(d => yScale(d.diff))
            .curve(d3.curveMonotoneX);

        // Draw the historical difference line.
        g.append("path")
            .datum(this.diffSeries)
            .attr("fill", "none")
            .attr("stroke", "#1f77b4")
            .attr("stroke-width", 2)
            .style("stroke-dasharray", "0")
            .attr("d", lineGen);

        if(isStationary) {
            // Optionally: Add OU forecast line here if desired.
            g.append("text")
              .attr("x", innerWidth/2)
              .attr("y", 15)
              .attr("text-anchor", "middle")
              .style("fill", "green")
              .style("font-size", "12px")
              .text("ADF test passed: Series is stationary. OU process can be applied.");
        } else {
            g.append("text")
              .attr("x", innerWidth/2)
              .attr("y", 15)
              .attr("text-anchor", "middle")
              .style("fill", "red")
              .style("font-size", "12px")
              .text("ADF test failed: Series is non-stationary. OU process not applied.");
        }
    }
}
